// Generated by CoffeeScript 1.4.0
(function() {
  var Chess, Move, Piece, alg2coor, array_belong, arrays_equal, validate_FEN, zeroArray;

  zeroArray = function(len) {
    var i, _i, _results;
    _results = [];
    for (i = _i = 1; 1 <= len ? _i <= len : _i >= len; i = 1 <= len ? ++_i : --_i) {
      _results.push(0);
    }
    return _results;
  };

  arrays_equal = function(a, b) {
    return !(a < b || b < a);
  };

  array_belong = function(array, element) {
    var el, _i, _len;
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      el = array[_i];
      if (arrays_equal(el, element)) {
        return true;
      }
    }
    return false;
  };

  alg2coor = function(alg) {
    var column, row;
    column = 'abcdefgh'.split('').indexOf(alg.charAt(0));
    row = 8 - parseInt(alg.charAt(1));
    return 16 * row + col;
  };

  /* 
  function to validate a fen string
  1. check if there are 6 elements: position, turn, castle,enpassant,pawnMoves,movesLength
  2. check if pawnMoves >= 0 and movesLength > 0
  3. check if turn is 'w' or 'b'
  4. check the validity of enpassant
  5. check the validity of castle
  6. test position
    6.1. exactly 8 row
    6.2. no two consecutive numbers
    6.3. only rnbqkRNBQK characters in first and last rows
    6.4. only prnbqkRNBQK characters in others rows
    6.5. at max 8 pawns, 1 king and 16 piece for players
  */


  validate_FEN = function(fen) {
    var fenArray, i, k, previous_was_number, rows, sum_fields, sum_kings, sum_pawns, sum_pieces, _i, _j, _len, _ref;
    fenArray = fen.split(/\s+/);
    if (fenArray.length !== 6) {
      return false;
    }
    if (isNaN(fenArray[5]) || parseInt(fenArray[5], 10) <= 0) {
      return false;
    }
    if (isNaN(fenArray[4]) || parseInt(fenArray[4], 10) < 0) {
      return false;
    }
    if (!/^(w|b)$/.test(fenArray[1])) {
      return false;
    }
    if (!/^(-|[abcdefgh][36])$/.test(fenArray[3])) {
      return false;
    }
    if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(fenArray[2])) {
      return false;
    }
    rows = fenArray[0].split("/");
    if (rows.length !== 8) {
      return false;
    }
    sum_pawns = [0, 0];
    sum_kings = [0, 0];
    sum_pieces = [0, 0];
    for (i = _i = 0; _i <= 7; i = ++_i) {
      sum_fields = 0;
      previous_was_number = false;
      _ref = rows[i];
      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
        k = _ref[_j];
        if (!isNaN(k)) {
          if (previous_was_number) {
            return false;
          }
          sum_fields += parseInt(k);
          previous_was_number = true;
        } else {
          if (i === 0 || i === 7) {
            if (!/^[rnbqkRNBQK]$/.test(k)) {
              return false;
            } else if (!/^[prnbqkPRNBQK]$/.test(k)) {
              return false;
            }
            sum_fields += 1;
            previous_was_number = false;
            if (k === k.toUpperCase()) {
              sum_pieces[0]++;
              if (k === 'P') {
                sum_pawns[0]++;
              }
              if (k === 'K') {
                sum_kings[0]++;
              }
            } else {
              sum_pieces[1]++;
              if (k === 'p') {
                sum_pawns[1]++;
              }
              if (k === 'k') {
                sum_kings[1]++;
              }
            }
          }
        }
      }
    }
    if (sum_fields !== 8) {
      return false;
    }
    if (sum_pawns[0] > 8 || sum_pawns[1] > 8 || sum_kings[0] !== 1 || sum_kings[1] !== 1 || sum_pieces[0] > 16 || sum_pieces[1] > 16) {
      false;
    }
    return true;
  };

  /*
  class Move to extend in the future
  */


  Move = (function() {

    function Move(coor, isPromotion, promotion, fen) {
      this.coor = coor;
      this.isPromotion = isPromotion;
      this.promotion = promotion;
      this.fen = fen;
    }

    return Move;

  })();

  /*
  class Piece.
    variable: color,type
    methods:
      setType to change type (promotion)
      getFEN to get the character of the piece in the fenstring
  */


  Piece = (function() {

    function Piece(color, type) {
      this.color = color;
      this.type = type;
    }

    Piece.setType = function(newType) {
      return this.type = type;
    };

    Piece.getFEN = function() {
      var fenChar, fenChear;
      fenChear = this.type.charAt(0);
      if (this.color) {
        fenChar = fenChar.toLowerCase();
      }
      return fenChar;
    };

    return Piece;

  })();

  /*
  class Chess.
    public variables:
      movesList is the list of moves
      kingsPosition is an array with the positions of the kings (usefull for test the checks)
      position is the board
      castles is an arrray with the avaiblity of castling
      legalMoves is an array of the coordinates of the possible moves
      turn is 0 if it's white turn or 1 if it's black turn
    private variables:
      defaultFEN is a string with the startpos
      actualCoordinates is an array with the coordinates of the current move
      actualIsPromotion is a booleane set to true is is a promotion move
      actualPromotion is the id of the piece to wich promove
      enPassant is coordinate of enpassant square
      zIndex is an integer to enshure that the piece dragged is over the others
      pawnMoves is the number of consecutive moves of non pawn piece
  */


  Chess = (function() {
    var actualCoordinates, actualIsPromotion, actualPromotion, defaultFEN, enPassant, pawnMoves, zIndex;

    function Chess() {}

    Chess.movesList = [];

    Chess.kingsPosition = [116, 4];

    Chess.position = zeroArray(128);

    Chess.castles = [[true, true], [true, true]];

    Chess.legalMoves = [];

    Chess.turn = 0;

    defaultFEN = 'rnbqkbnr\/pppppppp\/8\/8\/8\/8\/PPPPPPPP\/RNBQKBNR w KQkq - 0 1';

    actualCoordinates = [];

    actualIsPromotion = false;

    actualPromotion = 0;

    enPassant = -1;

    zIndex = 50;

    pawnMoves = 0;

    Chess.restart = function() {
      this.parseFEN(defaultFEN);
      this.movesList = [];
      return this.findLegalMoves();
    };

    Chess.parseFEN = function(fen) {
      var actualIndex, ch, col, color, fenObj, pieceType, row, _i, _j, _len, _len1, _ref, _ref1;
      this.position = zeroArray(128);
      if (!validate_FEN(fen)) {
        fen = defaultFEN;
      }
      fenObj = _.object(['position', 'turn', 'castle', 'enpassant', 'pawnMoves', 'movesLength'], fen.split(' '));
      actualIndex = 0;
      _ref = fenObj.position;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ch = _ref[_i];
        if (!isNaN(ch)) {
          actualIndex += parseInt(ch);
        } else {
          if (ch === '\/') {
            actualIndex += 8;
          } else {
            color = ch === ch.toLowerCase() ? 1 : void 0;
            pieceType = _.find(['PAWN', 'ROOK', 'NIGHT', 'BISHOP', 'QUEEN', 'KING'], function(str) {
              return str.charAt(0) === ch.toUpperCase();
            });
            this.position[actualIndex] = new Piece(color, pieceType);
            if (ch === 'k') {
              this.kingsPosition[1] = actualIndex;
            }
            if (ch === 'K') {
              this.kingsPosition[0] = actualIndex;
            }
            actualIndex++;
          }
        }
      }
      this.turn = fenObj.turn === 'w' ? 0 : 1;
      this.castles = [[false, false], [false, false]];
      _ref1 = fenObj.castle;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        ch = _ref1[_j];
        if (ch === '-') {
          break;
        }
        row = ch === ch.toLowerCase() ? 1 : 0;
        col = ch.toLowerCase() === 'k' ? 1 : 0;
        this.castles[row][col] = true;
      }
      if (fenObj.enpassant !== '-') {
        enPassant = alg2coor(fenObj.enpassant);
      }
      return pawnMoves = parseInt(fenObj.pawnMoves);
    };

    Chess.getFEN = function() {
      var castleAvaible, col, fen, i, j, piece, pos, row, zeroCount, _i, _j, _k, _l;
      fen = '';
      for (row = _i = 0; _i <= 7; row = ++_i) {
        zeroCount = 0;
        for (col = _j = 0; _j <= 7; col = ++_j) {
          pos = 16 * row + col;
          piece = this.position[pos];
          if (piece === 0) {
            zeroCount++;
          } else if (zeroCount > 0) {
            fen += zeroCount + piece.getFEN();
            zeroCount = 0;
          } else {
            fen += piece.getFEN();
          }
          if (zeroCount !== 0) {
            fen += zeroCount;
          }
          if (row !== 7) {
            fen += "\/";
          }
        }
      }
      fen = fen + ' ' + ['w', 'b'][this.turn] + ' ';
      castleAvaible = false;
      for (i = _k = 0; _k <= 1; i = ++_k) {
        for (j = _l = 0; _l <= 1; j = ++_l) {
          if (this.castles[i][1 - j]) {
            castleAvaible = true;
            fen += [['Q', 'K'], ['q', 'k']][i][1 - j];
          }
        }
      }
      if (!castleAvaible) {
        fen += '-';
      }
      fen += ' ';
      if (enPassant !== -1) {
        fen += coor2alg(enPassant);
      } else {
        fen += '-';
      }
      fen += ' ' + pawnMoves;
      fen += ' ' + Math.floor(this.movesList.length / 2 + 1);
      return fen;
    };

    Chess.executeMove = function(move) {
      var capturedPiece, capturedPosition, diff, from, piece, rookFrom, rookTo, to;
      from = move.coor[0];
      to = move.coor[1];
      piece = this.position[from];
      capturedPiece = this.position[to];
      this.position[to] = piece;
      this.position[from] = 0;
      switch (piece.type) {
        case 'PAWN':
          diff = Math.abs(from - to);
          if (diff === 32) {
            enPassant = from > to ? to + 16 : to - 16;
          } else if ((diff === 15 || diff === 17) && !capturedPiece) {
            capturedPosition = from > to ? to + 16 : to - 16;
            capturedPiece = this.position[capturedPosition];
            this.position[capturedPosition] = 0;
          }
          break;
        case 'KING':
          this.kingsPosition[this.turn] = to;
          this.castles[this.turn] = [false, false];
          if (Math.abs(from - to) === 2) {
            rookTo = from + (from > to ? -1 : 1);
            rookFrom = from + (from > to ? -4 : 3);
            this.position[rookTo] = this.position[rookFrom];
            this.position[rookFrom] = 0;
          }
          break;
        case 'ROOK':
          if (this.turn === 1) {
            if (from === 0) {
              this.castles[1][0] = false;
            } else if (from === 7) {
              this.castles[1][1] = false;
            }
          } else if (this.turn === 0) {
            if (from === 112) {
              this.castles[0][0] = false;
            } else if (from === 119) {
              this.castles[0][1] = false;
            }
          }
      }
      if (move.isPromotion) {
        this.position[to].type = ['QUEEN', 'ROOK', 'NIGHT', 'BISHOP'][move.promotion];
      }
      this.turn = 1 - this.turn;
      return capturedPiece;
    };

    Chess.isChecked = function(player) {
      var bdir, i, k, ndir, occupied, onBoard, rdir, self, _i, _j, _k, _len, _len1, _len2;
      self = this;
      bdir = [-15, 15, -17, 17];
      rdir = [-1, 1, -16, 16];
      ndir = [-14, 14, -18, 18, -31, 31, -33, 33];
      i = self.kingsPosition[player];
      for (_i = 0, _len = bdir.length; _i < _len; _i++) {
        k = bdir[_i];
        onBoard = _.filter(_.map(_.range(1, 8), function(num) {
          return i + num * k;
        }), function(num) {
          return !(num & 0x88);
        });
        occupied = _.find(onBoard, function(num) {
          return self.position[num] !== 0;
        });
        if (!_.isUndefined(occupied) && self.position[occupied].color === 1 - player && ['QUEEN', 'BISHOP'].indexOf(self.position[occupied].type) !== -1) {
          return true;
        }
      }
      for (_j = 0, _len1 = rdir.length; _j < _len1; _j++) {
        k = rdir[_j];
        onBoard = _.filter(_.map(_.range(1, 8), function(num) {
          return i + num * k;
        }), function(num) {
          return !(num & 0x88);
        });
        occupied = _.find(onBoard, function(num) {
          return self.position[num] !== 0;
        });
        if (!_.isUndefined(occupied) && self.position[occupied].color === 1 - player && ['QUEEN', 'ROOK'].indexOf(self.position[occupied].type) !== -1) {
          return true;
        }
      }
      for (_k = 0, _len2 = ndir.length; _k < _len2; _k++) {
        k = ndir[_k];
        if (!((i + k) & 0x88) && self.position[i + k].color === 1 - player && self.position[i + k].type === 'NIGHT') {
          return true;
        }
      }
      if (player === 0) {
        if (!((i - 15) & 0x88) && self.position[i - 15].type === 'PAWN' && self.position[i - 15].color === 1) {
          return true;
        }
        if (!((i - 17) & 0x88) && self.position[i - 17].type === 'PAWN' && self.position[i - 17].color === 1) {
          return true;
        }
      }
      if (player === 1) {
        if (!((i + 15) & 0x88) && self.position[i + 15].type === 'PAWN' && self.position[i + 15].color === 0) {
          return true;
        }
        if (!((i + 17) & 0x88) && self.position[i + 17].type === 'PAWN' && self.position[i + 17].color === 0) {
          return true;
        }
      }
      return false;
    };

    Chess.isCheckMate = function() {
      return this.isChecked(this.turn) && this.legalMoves.length === 0;
    };

    Chess.isStaleMate = function() {
      return !this.isChecked(this.turn) && this.legalMoves.length === 0;
    };

    Chess.findLegalMoves = function() {
      var bdir, castleMoves, i, k, kdir, movesTemp, ndir, piece, posToCheck, rdir, s, step, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _o;
      bdir = [-15, 15, -17, 17];
      rdir = [-1, 1, -16, 16];
      ndir = [-14, 14, -18, 18, -31, 31, -33, 33];
      kdir = [-1, 1, -16, 16, -15, 15, -17, 17];
      s = 1;
      piece = -1;
      movesTemp = [];
      this.legalMoves = [];
      for (i = _i = 0; _i <= 127; i = ++_i) {
        piece = this.position[i];
        if (piece.color !== this.turn) {
          continue;
        } else {
          switch (piece.type) {
            case 'PAWN':
              if (this.turn === 0) {
                if (!this.position[i - 16]) {
                  movesTemp.push([i, i - 16]);
                  if ((i & 0x70) === 0x60 && !this.position[i - 32]) {
                    movesTemp.push([i, i - 32]);
                  }
                }
                if (!((i - 15) & 0x88) && this.position[i - 15] && this.position[i - 15].color !== this.turn) {
                  movesTemp.push([i, i - 15]);
                }
                if (!((i - 17) & 0x88) && this.position[i - 17] && this.position[i - 17].color !== this.turn) {
                  movesTemp.push([i, i - 17]);
                }
              } else {
                if (!this.position[i + 16]) {
                  movesTemp.push([i, i + 16]);
                  if ((i & 0x70) === 0x10 && !this.position[i + 32]) {
                    movesTemp.push([i, i + 32]);
                  }
                }
                if (!((i + 15) & 0x88) && this.position[i + 15] && this.position[i + 15].color !== this.turn) {
                  movesTemp.push([i, i + 15]);
                }
                if (!((i + 17) & 0x88) && this.position[i + 17] && this.position[i + 17].color !== this.turn) {
                  movesTemp.push([i, i + 17]);
                }
              }
              break;
            case 'NIGHT':
              for (_j = 0, _len = ndir.length; _j < _len; _j++) {
                k = ndir[_j];
                if (!((i + k) & 0x88) && (this.position[i + ndir[k]] === 0 || this.position[i + k].color !== this.turn)) {
                  movesTemp.push([i, i + k]);
                }
              }
              break;
            case 'BISHOP':
              for (_k = 0, _len1 = bdir.length; _k < _len1; _k++) {
                k = bdir[_k];
                step = 1;
                while (!((i + step * k) & 0x88) && !this.position[i + step * k]) {
                  movesTemp.push([i, i + step * k]);
                  step++;
                }
                if (!((i + step * k) & 0x88) && this.position[i + step * k].color !== this.turn) {
                  movesTemp.push([i, i + step * k]);
                }
              }
              break;
            case 'ROOK':
              for (_l = 0, _len2 = rdir.length; _l < _len2; _l++) {
                k = rdir[_l];
                step = 1;
                while (!((i + step * k) & 0x88) && !this.position[i + step * k]) {
                  movesTemp.push([i, i + step * k]);
                  step++;
                }
                if (!((i + step * k) & 0x88) && this.position[i + step * k].color !== this.turn) {
                  movesTemp.push([i, i + step * k]);
                }
              }
              break;
            case 'QUEEN':
              for (_m = 0, _len3 = kdir.length; _m < _len3; _m++) {
                k = kdir[_m];
                step = 1;
                while (!((i + step * kdir[k]) & 0x88) && !this.position[i + step * kdir[k]]) {
                  movesTemp.push([i, i + step * kdir[k]]);
                  step++;
                }
                if (!((i + step * kdir[k]) & 0x88) && this.position[i + step * kdir[k]].color !== this.turn) {
                  movesTemp.push([i, i + step * kdir[k]]);
                }
              }
              break;
            case 'KING':
              for (_n = 0, _len4 = kdir.length; _n < _len4; _n++) {
                k = kdir[_n];
                if (!((i + k) & 0x88) && (!this.position[i + k] || this.position[i + k].color !== this.turn)) {
                  movesTemp.push([i, i + k]);
                }
              }
          }
        }
      }
      if (enPassant !== -1) {
        for (i = _o = 0; _o <= 1; i = ++_o) {
          posToCheck = enPassant + (this.turn === 0 ? 16 : -16) + Math.pow(-1, i);
          if (!(posToCheck & 0x88) && this.position[posToCheck] !== 0 && this.position[posToCheck].color === this.turn && this.position[posToCheck].type === 'PAWN') {
            movesTemp.push([posToCheck, enPassant]);
          }
        }
      }
      this.legalMoves = movesTemp.filter(function(move) {
        var castlesTemp, j, kingsTemp, positionTemp, result, turnTemp, _len5, _len6, _p, _q, _r, _ref, _ref1, _s, _t, _u, _v;
        castlesTemp = [[0, 0], [0, 0]];
        turnTemp = this.turn;
        positionTemp = [];
        kingsTemp = [];
        _ref = this.position;
        for (_p = 0, _len5 = _ref.length; _p < _len5; _p++) {
          i = _ref[_p];
          positionTemp.push(i);
        }
        _ref1 = this.kingsPosition;
        for (_q = 0, _len6 = _ref1.length; _q < _len6; _q++) {
          i = _ref1[_q];
          kingsTemp.push(i);
        }
        for (i = _r = 0; _r <= 1; i = ++_r) {
          for (j = _s = 0; _s <= 1; j = ++_s) {
            castlesTemp[i][j] = this.castles[i][j];
          }
        }
        this.executeMove({
          'coor': move,
          'type': 0,
          'promotion': 0
        });
        result = !this.isChecked(1 - this.turn) ? true : false;
        for (i = _t = 0; _t <= 128; i = ++_t) {
          this.position[i] = positionTemp[i];
        }
        for (i = _u = 0; _u <= 1; i = ++_u) {
          this.kingsPosition[i] = kingsTemp[i];
          for (j = _v = 0; _v <= 1; j = ++_v) {
            this.castles[i][j] = castlesTemp[i][j];
          }
        }
        this.turn = turnTemp;
        return result;
      });
      movesTemp = [];
      if (this.turn === 0 && this.castles[0][1] && !this.position[7 * 16 + 5] && !this.position[7 * 16 + 6] && array_belong(this.legalMoves, [7 * 16 + 4, 7 * 16 + 5])) {
        movesTemp.push([7 * 16 + 4, 7 * 16 + 6]);
      }
      if (this.turn === 0 && this.castles[0][0] && !this.position[7 * 16 + 1] && !this.position[7 * 16 + 2] && !this.position[7 * 16 + 3] && array_belong(this.legalMoves, [7 * 16 + 4, 7 * 16 + 3])) {
        movesTemp.push([7 * 16 + 4, 7 * 16 + 2]);
      }
      if (this.turn === 1 && this.castles[1][1] && !this.position[5] && !this.position[6] && array_belong(this.legalMoves, [4, 5])) {
        movesTemp.push([4, 6]);
      }
      if (this.turn === 1 && this.castles[1][0] && !this.position[1] && !this.position[2] && !this.position[3] && array_belong(this.legalMoves, [4, 3])) {
        movesTemp.push([4, 2]);
      }
      castleMoves = movesTemp.filter(function(move) {
        var castlesTemp, j, kingsTemp, positionTemp, result, turnTemp, _len5, _len6, _p, _q, _r, _ref, _ref1, _s, _t, _u, _v;
        castlesTemp = [[0, 0], [0, 0]];
        turnTemp = this.turn;
        positionTemp = [];
        kingsTemp = [];
        _ref = this.position;
        for (_p = 0, _len5 = _ref.length; _p < _len5; _p++) {
          i = _ref[_p];
          positionTemp.push(i);
        }
        _ref1 = this.kingsPosition;
        for (_q = 0, _len6 = _ref1.length; _q < _len6; _q++) {
          i = _ref1[_q];
          kingsTemp.push(i);
        }
        for (i = _r = 0; _r <= 1; i = ++_r) {
          for (j = _s = 0; _s <= 1; j = ++_s) {
            castlesTemp[i][j] = this.castles[i][j];
          }
        }
        this.executeMove({
          'coor': move,
          'type': 0,
          'promotion': 0
        });
        result = !this.isChecked(1 - this.turn) ? true : false;
        for (i = _t = 0; _t <= 128; i = ++_t) {
          this.position[i] = positionTemp[i];
        }
        for (i = _u = 0; _u <= 1; i = ++_u) {
          this.kingsPosition[i] = kingsTemp[i];
          for (j = _v = 0; _v <= 1; j = ++_v) {
            this.castles[i][j] = castlesTemp[i][j];
          }
        }
        this.turn = turnTemp;
        return result;
      });
      enPassant = -1;
      Array.prototype.push.apply(this.legalMoves, castleMoves);
      return true;
    };

    Chess.move2PGN = function(start, end, capturing, otherMoves) {
      var endString, moveString, o, others, piece, self, uniqueCol, uniqueRow, _i, _j, _len, _len1;
      self = this;
      piece = self.position[end];
      moveString = '';
      endString = coor2alg(end);
      if (piece.type !== 'PAWN' && !actualIsPromotion) {
        moveString += piece.type.charAt(0);
      } else if (Math.abs(start - end) === 15 || Math.abs(start - end) === 17) {
        moveString += coor2alg(start).charAt(0);
      }
      others = _.map(_.filter(otherMoves, function(move) {
        return move[1] === end && move[0] !== start && self.position[move[0]].type === piece.type;
      }), function(move) {
        return move[0];
      });
      uniqueCol = true;
      for (_i = 0, _len = others.length; _i < _len; _i++) {
        o = others[_i];
        if ((o - start) % 16 === 0) {
          uniqueCol = false;
          break;
        }
      }
      uniqueRow = true;
      if (!uniqueCol) {
        for (_j = 0, _len1 = others.length; _j < _len1; _j++) {
          o = others[_j];
          if ((start - (start % 16)) / 16 === (o - (o % 16)) / 16) {
            uniqueRow = false;
            break;
          }
        }
      }
      if (piece.type === 'PAWN') {
        uniqueRow = true;
        uniqueCol = true;
      }
      if (others.length > 0) {
        if (uniqueCol) {
          moveString += coor2alg(start).charAt(0);
        } else if (uniqueRow(moveString += coor2alg(start).charAt(1))) {

        } else {
          moveString += coor2alg(start);
        }
      }
      if (capturing) {
        moveString += 'x';
      }
      moveString += endString;
      if (piece.type === 'KING') {
        if (end - start === 2) {
          moveString = 'O-O';
        }
        if (end - start === -2) {
          moveString = 'O-O-O';
        }
      }
      if (actualIsPromotion) {
        moveString += '=' + 'QRNB'.charAt(actualPromotion);
      }
      if (self.isChecked(self.turn)) {
        if (self.isCheckMate()) {
          moveString += '#';
        } else {
          moveString += '+';
        }
      }
      return moveString;
    };

    Chess.pgn2move = function(pgn) {
      var col, endSquare, fen, filteredMoves, row, self, splittedPgn, startString, t, _coor, _isPromo, _promo;
      fen = '';
      self = this;
      pgn = pgn.replace('+', '').replace('#', '').replace('x', '');
      if (pgn === 'O-O') {
        if (self.turn === 0) {
          _coor = [7 * 16 + 4, 7 * 16 + 6];
        }
        if (self.turn === 1) {
          _coor = [4, 6];
        }
      } else if (pgn === 'O-O-O') {
        if (self.turn === 0) {
          _coor = [7 * 16 + 4, 7 * 16 + 2];
        }
        if (self.turn === 1) {
          _coor = [4, 2];
        }
      } else {
        splittedPgn = pgn.split('=');
        if (splittedPgn.length === 2) {
          _isPromo = true;
          _promo = ['Q', 'R', 'N', 'B'].indexOf(splittedPgn[1]);
        }
        pgn = splittedPgn[0];
        endSquare = alg2coor(pgn.slice(pgn.length - 2, pgn.length));
        startString = pgn.slice(0, pgn.length - 2);
        if (startString.length > 0 && startString.charAt(0) === startString.charAt(0).toUpperCase()) {
          t = startString.charAt(0);
        } else {
          startString = 'P' + startString;
          t = 'P';
        }
        filteredMoves = _.filter(self.legalMoves, function(coor) {
          return coor[1] === endSquare && self.position[coor[0]].type.charAt(0) === t;
        });
        if (filteredMoves.length === 1) {
          _coor = filteredMoves[0];
        } else if (filteredMoves.length === 2) {
          col = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'].indexOf(startString.charAt(1));
          if (col !== -1) {
            filteredMoves = _.filter(filteredMoves, function(coor) {
              return (coor[0] - col) % 16 === 0;
            });
          } else {
            filteredMoves = _.filter(filteredMoves, function(coor) {
              return Math.abs(coor[0] - parseInt(startString.charAt(1))) <= 7;
            });
          }
        } else if (filteredMoves.length === 3) {
          col = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'].indexOf(startString.charAt(1));
          row = parseInt(startString.charAt(1));
          filteredMoves = _.filter(filteredMoves, function(coor) {
            return Math.abs(coor[0] - row) <= 7 && (coor[0] - col) % 16 === 0;
          })(_coor = filteredMoves[0]);
        }
        _coor = filteredMoves[0];
      }
      return new Move(_coor, _isPromo, _promo, _fen);
    };

    return Chess;

  })();

}).call(this);
